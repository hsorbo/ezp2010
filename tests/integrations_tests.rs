#[cfg(test)]
mod tests {
    use ezp::db;
    use ezp::ezp_commands;

    #[test]
    fn create_read_cmd() {
        let known = [
            ("110a02000000000000200024000000", "24C64 3V"),     //24XX
            ("110a02000000000000200024000100", "24C64 5V"),     //24XX
            ("110a02000000000000001014000100", "MIC24LC00"),    //24XX
            ("110a02000000000000010014000100", "AT24C02"),      //24XX
            ("110a02000000000000080014000100", "MIC24LC16B"),   //24XX
            ("110a02000000000000080014000100", "AT24C16"),      //24XX
            ("110a02000000000000100024000000", "24C32 3V"),     //24XX
            ("110a02000000000000200024000100", "ST24C64"),      //24XX
            ("110a02000000000000400024000100", "MIC24LC128"),   //24XX
            ("110a02000000000000800024000100", "MIC24LC256"),   //24XX
            ("110a02000000000001000024000100", "AT24C512A"),    //24XX
            ("110a02000000000002000024000100", "MIC24AA1024"),  //24XX
            ("110a03000000000000008001000100", "25010"),        //25XX
            ("110a03000000000000020001000100", "25040"),        //25XX
            ("110a03000000000000040011000100", "25080"),        //25XX
            ("110a03000000000000200011000100", "25640"),        //25XX
            ("110a03000000000000400011000100", "25128"),        //25XX
            ("110a04000000000000008068010100", "AK93C45AV"),    // 93XX
            ("110a04000000000000008078030100", "93C46(8bit)"),  // 93XX
            ("110a04000000000000008068010100", "93C46(16bit)"), // 93XX
            ("110a01000000000001000003000000", "25X512"),       // SPI
            ("110a01000000000010000003000000", "W25X80L"),      // SPI
            ("110a01000000000040000003000000", "AT25DF321"),    // SPI
            ("110a01000000000100000003000000", "W25Q128BV"),    // SPI
        ];
        for (read, name) in known {
            let data = hex::decode(read).unwrap();
            let entry = db::get_by_product_name(name).unwrap();
            let got = ezp_commands::create_read_cmd(
                &entry.chip_type,
                entry.size,
                entry.flags(),
                entry.is5v(),
            );
            assert_eq!(data, got);
        }
    }

    #[test]
    fn create_write_cmd() {
        let known = [
            ("120c020000000000000010000114000000", "24C00 3V"),           // 24XX
            ("120c020000000000020000008024000000", "24C1024 3V"),         // 24XX
            ("120c020000000000020000008024000100", "24C1024 5V"),         // 24XX
            ("120c030000000000000080000401000100", "AT25010"),            // 93XX
            ("120c030000000000000800001011000100", "MIC25LC160"),         // 93XX
            ("120c030000000000000400000811000100", "ST25W08"),            // 93XX
            ("120c040000000000000080000168010100", "AK93C45AV"),          // 25XX
            ("120c0400000000000008000001b8030100", "AT93C86(8bit)-SOP8"), // 25XX
            ("120c040000000000000020000168010100", "FM93C06AM8(16bit)"),  // 25XX
            ("120c0400000000000008000001a8010100", "NSC93C86"),           // 25XX
            ("120c010000000000100000010003000000", "W25X80L"),            // SPI
            ("120c010000000000400000010003000000", "AT25DF321"),          // SPI
            ("120c010000000001000000010003000000", "W25Q128BV"),          // SPI
        ];

        for (read, name) in known {
            let data = hex::decode(read).unwrap();
            let entry = db::get_by_product_name(name).unwrap();
            let got = ezp_commands::create_write_cmd(
                &entry.chip_type,
                entry.size,
                entry.flags(),
                entry.write_flag,
                entry.is5v(),
            );
            assert_eq!(data, got);
        }
    }
}
